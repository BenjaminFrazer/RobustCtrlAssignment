* Notes on Base neural controller 
A Neural net was implemented as a function taking two arguments:
- the neural parms i.e. weights and thresholds
- the current value of the sensors

The code is as follows.
#+begin_src octave
ML = (input.LS*Params.W1+input.RS*Params.W3)>=Params.T1;
MR = (input.RS*Params.W4+input.LS*Params.W2)>=Params.T2;
#+end_src 

Using the base parameters and the neurons threshold activation function, at 
max sensor distance (1) the robot still has one wheel going forward and one 
stationary meaning it turns in a circle. 

* Notes on improving neural net
** Maximum distance behavior
Though not specified, the  activation function for the neural net is assumed to be a simple threshold meaning that the output of the net may only be a one or a zero. this means that any motor may only be in one of two states. these could be:
- forward or off
- forward and backward

It is possible to implement a controller for either configuration, however the first option is substantially more challenging this is what i cose to implement and describe here.

*** difficulties
It is worth noting that the limited number of neurons in the network impose fundamental geometric limitations on the logical rules that may be implement. If one considers the inputs to the robot to be a two dimensional state-space, it can be shown that any combination two weights and biases must constitute a strait line bisecting the state-space. Depending on the output "wiring" of the neural net to the motors the area enclosed by one of these lines will mean either full forward or reverse/stop for the output of a given wheel as a function of the input states. When the lines for each wheel are drawn on the state-space the intersection of the areas where the wheels are moving forward will constitute forward motion for the robot as a whole, while the areas were both are zero will be either stationary or in full reverse depending on what the output of logical zero from the neural net maps to.

A basic fundamental requirement of the robot be that it should go in a strait line when there are no obstacles in front of it. Since the sensor saturate at distance >1. The only thing that must be satisfied in the state-space is that the infinitesimal region around Rs=1 and LS=1 be an intersection of the two regions corresponding to forward motion of each wheel.

The second constraint relates to the turning circle of the robot, from testing, it was observed that the turning circle with one wheel stationary, is ~0.8, this means that the robot must begin turning almost as soon as it the object is in sensory range. This imposes a second geometric constraint, that any

[[file:Figures/StateSpace_Neuron.png]]


This means that the turning options of the robot in the former case are either turn in a large arc, or turn on the spot in the latter case. It turns out it is possible to implement a collision avoidance robot with both options, the latter option has some difficulties associated with it.

the proposed architecture, the neural net based controller is extreme limited in the behavior it can be made to elicit.
The behavior at maximum distance may be specified as a condition that must be satisfied by the logic of the controller.
#+NAME: tabNetParams
|   | T1 | T2 | W1 | W2 | w3  | w4    | Bias_ML | Bias_MR |
|---+----+----+----+----+-----+-------+---------+---------|
| _ | T1 | T2 | W1 | W2 | W3  | W4    | Bias_ML | Bias_MR |
|   | 0  | 0  | -1 | 1  | 1.1 | -0.64 | 0       | -0.3    |

|   | Rule # |  LS |   RS | MR_target | MR_sum(W1+W3) | ML_target(W4+W2) | ML_sum |
|---+--------+-----+------+-----------+---------------+------------------+--------|
| ! |        |  LS |   RS |           |        MR_sum |                  | ML_sum |
| # |      1 |   1 |    1 |         1 |           0.2 |                1 |    0.1 |
| # |      2 | 0.5 |  0.5 |         0 |         -0.05 |                1 |   0.05 |
| # |        | 0.5 |  0.6 |         0 |          -0.1 |                1 |   0.16 |
| # |        | 0.6 |  0.5 |         1 |          0.05 |                0 |  -0.05 |
| # |      2 | 0.2 |  0.2 |         0 |          -0.2 |                1 |   0.02 |
| # |      2 | 0.1 |  0.1 |         0 |         -0.25 |                1 |   0.01 |
| # |      2 | 0.1 | 0.05 |         0 |        -0.225 |                0 | -0.045 |
#+TBLFM: $8=$LS*remote(tabNetParams,$W1)+$RS*remote(tabNetParams,$W3)+remote(tabNetParams,$Bias_ML):: $6=$RS*remote(tabNetParams,$W4)+$LS*remote(tabNetParams,$W2)+remote(tabNetParams,$Bias_MR)
- The problem may be defined in-terms of geometry, whereby the threshold function
